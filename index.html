<!DOCTYPE html>
<html>
<head>
    <title>Audio-Reactive Glitch Visualizer</title>
    <style>
        :root {
            --primary-color: #00ff41;
            --background-color: #000;
            --panel-bg: rgba(10, 25, 10, 0.8);
        }
        * {
            box-sizing: border-box;
        }
        body {
            background-color: var(--background-color);
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            color: var(--primary-color);
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-wrap: wrap;
        }
        canvas {
            background-color: var(--background-color);
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
        .controls {
            position: absolute;
            top: 15px;
            left: 15px;
            background: var(--panel-bg);
            backdrop-filter: blur(5px);
            padding: 15px;
            border: 1px solid var(--primary-color);
            z-index: 10;
            text-shadow: 0 0 5px var(--primary-color);
            transition: height 0.3s ease-in-out;
            max-width: 380px;
        }
        .controls.collapsed #controls-content {
            display: none;
        }
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .controls-header h2 {
            margin: 0;
            font-size: 1.2em;
        }
        #toggle-ui {
            font-size: 1.2em;
            font-weight: bold;
            user-select: none;
            padding: 0 5px;
        }
        #controls-content {
            padding-top: 10px;
        }
        .control-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            width: 80px;
            text-align: right;
        }
        button, select, input[type="file"]::-webkit-file-upload-button {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            padding: 5px 10px;
            cursor: pointer;
            font-family: inherit;
            text-shadow: inherit;
        }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%2300ff41" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat;
            background-position-x: 100%;
            background-position-y: 5px;
            padding-right: 25px;
        }
        select option {
            background: #0a190a;
            color: var(--primary-color);
        }
        #rainbowButton.active {
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            color: black;
            font-weight: bold;
            text-shadow: none;
        }
        input[type="color"] {
            -webkit-appearance: none;
            width: 40px;
            height: 25px;
            border: 1px solid var(--primary-color);
            padding: 0;
            background: transparent;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; }
        hr {
            border-color: var(--primary-color);
            border-style: solid;
            opacity: 0.5;
            margin: 15px 0;
        }
        audio {
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="controls" id="controls-panel">
        <div class="controls-header" id="controls-header">
            <h2>> VISUALIZER CTRL</h2>
            <div id="toggle-ui">[ - ]</div>
        </div>
        <div id="controls-content">
            <hr>
            <div class="control-group">
                <label for="layoutMode">Layout:</label>
                <select id="layoutMode">
                    <option value="single" selected>Single View</option>
                    <option value="quad">Quad View</option>
                </select>
            </div>
            <div class="control-group">
                <label for="visualizerMode">Mode:</label>
                <select id="visualizerMode">
                    <option value="lineBox" selected>Line Box</option>
                    <option value="radialPulse">Radial Pulse</option>
                    <option value="cubeField">Cube Field</option>
                </select>
            </div>
            <div class="control-group">
                <label for="speedSlider">Speed:</label>
                <input type="range" id="speedSlider" min="1" max="50" value="20">
            </div>
            <div class="control-group">
                <label for="colorPicker">Color:</label>
                <input type="color" id="colorPicker" value="#00ff41">
            </div>
            <div class="control-group">
                <button id="rainbowButton">Rainbow Mode</button>
            </div>
            <hr>
            <h2>> AUDIO SRC</h2>
            <input type="file" id="audioFile" class="audio-upload" accept="audio/*" />
            <audio id="audioPlayer" controls loop>
                <source src="song.mp3" type="audio/mpeg">
                Your browser does not support the audio element.
            </audio>
        </div>
    </div>
    
    <script>
        // ---- DOM elements ----
        const audio = document.getElementById('audioPlayer');
        const fileInput = document.getElementById('audioFile');
        const speedSlider = document.getElementById('speedSlider');
        const colorPicker = document.getElementById('colorPicker');
        const rainbowButton = document.getElementById('rainbowButton');
        const modeSelector = document.getElementById('visualizerMode');
        const layoutSelector = document.getElementById('layoutMode');
        const canvasContainer = document.getElementById('canvas-container');
        const controlsPanel = document.getElementById('controls-panel');
        const toggleUiButton = document.getElementById('toggle-ui');
        const controlsHeader = document.getElementById('controls-header');

        // ---- Global State ----
        let visualizerInstances = [];
        let globalTime = 0;

        // ---- Parameters ----
        let GRID_SIZE = 32;
        const CELL_SIZE = 120;
        const MAX_Z_DEFORMATION = 350;
        const NOISE_SCALE = 0.02;
        const GLITCH_INTENSITY = 10;
        const FOG_COLOR = 'rgba(0, 0, 0, 0.10)';
        const MAX_LINE_SEGMENTS = 5;
        const CUBE_COUNT = 40;
        let BASE_LINE_COLOR = colorPicker.value;
        let CURRENT_SPEED = speedSlider.value / 100;
        let IS_RAINBOW_MODE = false;
        
        // ---- Audio ----
        let audioContext, analyser, frequencyData, mediaElementSource;
        const FFT_SIZE = 256;
        let bassEnergy = 0, midHighEnergy = 0;
        
        // ---- FPS ----
        let fps = 60, frameCount = 0, fpsSampleStart = performance.now();
        let gridDetailReduced = false;

        // ---- UI Interaction ----
        controlsHeader.addEventListener('click', () => {
            const isCollapsed = controlsPanel.classList.toggle('collapsed');
            toggleUiButton.textContent = isCollapsed ? '[ + ]' : '[ - ]';
        });

        // ---- Audio Setup & Analysis ----
        function initAudio() {
            if (audioContext) return; // Already initialized
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
                mediaElementSource = audioContext.createMediaElementSource(audio);
                mediaElementSource.connect(analyser);
                analyser.connect(audioContext.destination);
            } catch (e) {
                console.error("AudioContext setup failed:", e);
                analyser = null;
            }
        }
        
        function analyzeAudio() {
            if (!analyser || audio.paused || !frequencyData) {
                bassEnergy = 0; midHighEnergy = 0; return;
            }
            analyser.getByteFrequencyData(frequencyData);
            let bassSum = 0, midHighSum = 0;
            const bassBins = Math.floor(frequencyData.length * 0.1);
            for (let i = 0; i < bassBins; i++) bassSum += frequencyData[i];
            const midHighStart = Math.floor(frequencyData.length * 0.4);
            for (let i = midHighStart; i < frequencyData.length; i++) midHighSum += frequencyData[i];
            bassEnergy = bassBins > 0 ? (bassSum / bassBins / 255) : 0;
            const midHighBins = frequencyData.length - midHighStart;
            midHighEnergy = midHighBins > 0 ? (midHighSum / midHighBins / 255) : 0;
        }

        // ---- Visualizer Instance Management ----
        function createVisualizerInstance(canvas, mode) {
            const instance = {
                canvas: canvas,
                ctx: canvas.getContext('2d'),
                mode: mode,
                camera: { x: 0, y: 150, z: -800, fov: 600, targetY: (Math.random() - 0.5) * 300 },
                points: [],
                cubes: [],
                noiseOffset: { x: Math.random() * 1000, y: Math.random() * 1000 },
                modeTransition: 0,
                chillParticles: []
            };
            initGrid(instance);
            initCubes(instance);
            spawnChillParticles(instance);
            return instance;
        }

        function setupVisualizers(layout) {
            canvasContainer.innerHTML = '';
            visualizerInstances = [];
            const modes = ['lineBox', 'radialPulse', 'cubeField', 'lineBox'];
            
            if (layout === 'single') {
                const canvas = document.createElement('canvas');
                canvasContainer.appendChild(canvas);
                const instance = createVisualizerInstance(canvas, modeSelector.value);
                visualizerInstances.push(instance);
                modeSelector.disabled = false;
            } else if (layout === 'quad') {
                for (let i = 0; i < 4; i++) {
                    const canvas = document.createElement('canvas');
                    canvasContainer.appendChild(canvas);
                    const instance = createVisualizerInstance(canvas, modes[i % modes.length]);
                    visualizerInstances.push(instance);
                }
                modeSelector.disabled = true;
            }
            handleResize();
        }

        function handleResize() {
            const layout = layoutSelector.value;
            let cols = (layout === 'quad') ? 2 : 1;
            let rows = (layout === 'quad') ? 2 : 1;
            
            visualizerInstances.forEach(instance => {
                instance.canvas.width = window.innerWidth / cols;
                instance.canvas.height = window.innerHeight / rows;
                spawnChillParticles(instance);
            });
        }
        
        // ---- Asset Initializers ----
        function initGrid(instance) {
            instance.points = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                instance.points.push([]);
                for (let j = 0; j < GRID_SIZE; j++) {
                    let x3D = (i - GRID_SIZE / 2) * CELL_SIZE;
                    let y3D = (j - GRID_SIZE / 2) * CELL_SIZE;
                    instance.points[i].push({ x: x3D, y: y3D, z: 0 });
                }
            }
        }
        function initCubes(instance) {
            instance.cubes = [];
            for (let i = 0; i < CUBE_COUNT; i++) {
                instance.cubes.push({
                    x: (Math.random() - 0.5) * 2000, y: (Math.random() - 0.5) * 2000, z: Math.random() * 2000,
                    size: 20 + Math.random() * 80, rotX: 0, rotY: 0, rotZ: 0,
                    rotSpeedX: (Math.random() - 0.5) * 0.01, rotSpeedY: (Math.random() - 0.5) * 0.01,
                });
            }
        }
        function spawnChillParticles(instance) {
            instance.chillParticles = [];
            for (let i = 0; i < 30; i++) {
                instance.chillParticles.push({
                    x: Math.random() * instance.canvas.width, y: Math.random() * instance.canvas.height,
                    r: 20 + Math.random() * 25, opacity: 0.09 + Math.random() * 0.15,
                    vx: (Math.random() - 0.5) * 0.3, vy: (Math.random() - 0.5) * 0.3,
                    pulse: 0, pulseSpeed: 0.01 + Math.random() * 0.01
                });
            }
        }
        
        // ---- Utility Functions ----
        function hexToRgbA(hex, alpha) {let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`;}
        function hsvToRgb(h,s,v){let r,g,b,i,f,p,q,t;i=Math.floor(h*6);f=h*6-i;p=v*(1-s);q=v*(1-f*s);t=v*(1-(1-f)*s);switch(i%6){case 0:r=v,g=t,b=p;break;case 1:r=q,g=v,b=p;break;case 2:r=p,g=v,b=t;break;case 3:r=p,g=q,b=v;break;case 4:r=t,g=p,b=v;break;case 5:r=v,g=p,b=q;break;}return"#" + [r, g, b].map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('');}
        function lerp(a,b,t){return a+t*(b-a);} function fade(t){return t*t*t*(t*(t*6-15)+10);} const permutation=new Array(512);const p_noise=new Array(256);for(let i=0;i<256;i++){p_noise[i]=Math.floor(Math.random()*256);} for(let i=0;i<512;i++){permutation[i]=p_noise[i&255];} function grad(hash,x,y,z){switch(hash&0xF){case 0x0:return x+y;case 0x1:return-x+y;case 0x2:return x-y;case 0x3:return-x-y;case 0x4:return x+z;case 0x5:return-x+z;case 0x6:return x-z;case 0x7:return-x-z;case 0x8:return y+z;case 0x9:return-y+z;case 0xA:return y-z;case 0xB:return-y-z;case 0xC:return y+x;case 0xD:return-y+z;case 0xE:return y-x;case 0xF:return-y-z;default:return 0;}}
        function perlinNoise(x,y,z){let X=Math.floor(x)&255,Y=Math.floor(y)&255,Z=Math.floor(z)&255;x-=Math.floor(x);y-=Math.floor(y);z-=Math.floor(z);let u=fade(x),v=fade(y),w=fade(z);let A=permutation[X]+Y,AA=permutation[A]+Z,AB=permutation[A+1]+Z;let B=permutation[X+1]+Y,BA=permutation[B]+Z,BB=permutation[B+1]+Z;return lerp(w,lerp(v,lerp(u,grad(permutation[AA],x,y,z),grad(permutation[BA],x-1,y,z)),lerp(u,grad(permutation[AB],x,y-1,z),grad(permutation[BB],x-1,y-1,z))),lerp(v,lerp(u,grad(permutation[AA+1],x,y,z-1),grad(permutation[BA+1],x-1,y,z-1)),lerp(u,grad(permutation[AB+1],x,y-1,z-1),grad(permutation[BB+1],x-1,y-1,z-1))));}

        // ---- Drawing Functions ----
        function project(p3d, instance) {
            const { camera, canvas } = instance;
            let tx = p3d.x - camera.x, ty = p3d.y - camera.y, tz = p3d.z - camera.z;
            if (camera.fov + tz <= 0) return { x: 0, y: 0, scale: -1, depth: tz };
            let scale = camera.fov / (camera.fov + tz);
            return { x: tx * scale + canvas.width / 2, y: ty * scale + canvas.height / 2, scale, depth: tz };
        }
        function drawGlitchyLine(p1, p2, instance) {
            const { ctx } = instance;
            if (p1.scale < 0 || p2.scale < 0) return;
            ctx.lineWidth = Math.max(0.25, 1 / (1 + p1.depth * 0.002));
            if (ctx.lineWidth < 0.2) return;
            let colorToUse = IS_RAINBOW_MODE ? hsvToRgb((globalTime * 0.01 + p1.depth * 0.001) % 1, 1, 1) : BASE_LINE_COLOR;
            ctx.strokeStyle = hexToRgbA(colorToUse, Math.max(0.1, 1 - Math.abs(p1.depth) / 2500));
            
            let numSegments = Math.min(MAX_LINE_SEGMENTS, Math.max(2, Math.floor(Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2) / 20)));
            for (let i = 0; i < numSegments; i++) {
                let jitter = (GLITCH_INTENSITY + midHighEnergy * 20) * (1 - p1.scale);
                let startX = lerp(p1.x, p2.x, i / numSegments) + (Math.random() - 0.5) * jitter;
                let startY = lerp(p1.y, p2.y, i / numSegments) + (Math.random() - 0.5) * jitter;
                let endX = lerp(p1.x, p2.x, (i + 1) / numSegments) + (Math.random() - 0.5) * jitter;
                let endY = lerp(p1.y, p2.y, (i + 1) / numSegments) + (Math.random() - 0.5) * jitter;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
        }
        function drawChillParticles(instance){const{ctx,canvas,chillParticles}=instance;ctx.save();ctx.globalAlpha=1-instance.modeTransition;for(const p of chillParticles){p.pulse+=p.pulseSpeed;let r=p.r+Math.sin(p.pulse)*3;p.x+=p.vx;p.y+=p.vy;if(p.x>canvas.width+r)p.x=-r;if(p.x<-r)p.x=canvas.width+r;if(p.y>canvas.height+r)p.y=-r;if(p.y<-r)p.y=canvas.height+r;const grad=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r);grad.addColorStop(0,`rgba(255,255,255,${p.opacity})`);grad.addColorStop(1,"rgba(255,255,255,0)");ctx.beginPath();ctx.arc(p.x,p.y,r,0,Math.PI*2);ctx.fillStyle=grad;ctx.fill();}ctx.restore();}
        function drawLineBox(instance){const{points,noiseOffset}=instance;const noiseZInput=globalTime*CURRENT_SPEED*.05+bassEnergy*5;for(let i=0;i<points.length;i++){for(let j=0;j<points[i].length;j++){let p=points[i][j];p.z=perlinNoise((p.x+noiseOffset.x)*NOISE_SCALE,(p.y+noiseOffset.y)*NOISE_SCALE,noiseZInput)*MAX_Z_DEFORMATION+bassEnergy*MAX_Z_DEFORMATION*2;}}for(let i=0;i<points.length;i++){for(let j=0;j<points[i].length;j++){let p1=project(points[i][j],instance);if(j<points[i].length-1){let p2=project(points[i][j+1],instance);drawGlitchyLine(p1,p2,instance);}if(i<points.length-1){let p2=project(points[i+1][j],instance);drawGlitchyLine(p1,p2,instance);}}}}
        function drawRadialPulse(instance){const{ctx,canvas}=instance;const centerX=canvas.width/2,centerY=canvas.height/2,numBars=analyser.frequencyBinCount,radius=50+bassEnergy*100;for(let i=0;i<numBars;i++){const barHeight=frequencyData[i]*(.5+bassEnergy*2),angle=i/numBars*Math.PI*2+globalTime*.001;const startX=centerX+Math.cos(angle)*radius,startY=centerY+Math.sin(angle)*radius;let endX=centerX+Math.cos(angle)*(radius+barHeight)+(Math.random()-.5)*midHighEnergy*30;let endY=centerY+Math.sin(angle)*(radius+barHeight)+(Math.random()-.5)*midHighEnergy*30;ctx.strokeStyle=IS_RAINBOW_MODE?hsvToRgb((i/numBars+globalTime*.001)%1,1,1):BASE_LINE_COLOR;ctx.lineWidth=1+frequencyData[i]/255*3;ctx.beginPath();ctx.moveTo(startX,startY);ctx.lineTo(endX,endY);ctx.stroke();}}
        function drawCubeField(instance){const vertices=[{x:-1,y:-1,z:-1},{x:1,y:-1,z:-1},{x:1,y:1,z:-1},{x:-1,y:1,z:-1},{x:-1,y:-1,z:1},{x:1,y:-1,z:1},{x:1,y:1,z:1},{x:-1,y:1,z:1}];const edges=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];for(const cube of instance.cubes){cube.rotX+=cube.rotSpeedX*(1+midHighEnergy*5);cube.rotY+=cube.rotSpeedY*(1+midHighEnergy*5);cube.z-=CURRENT_SPEED*10;if(cube.z+instance.camera.z<-instance.camera.fov){cube.z=2000;}const pulseSize=cube.size*(1+bassEnergy*1.5);const sx=Math.sin(cube.rotX),cx=Math.cos(cube.rotX),sy=Math.sin(cube.rotY),cy=Math.cos(cube.rotY);let projectedVertices=[];for(const v of vertices){let dy=v.y*cx-v.z*sx,dz=v.y*sx+v.z*cx,dx=v.x*cy-dz*sy;dz=v.x*sy+dz*cy;projectedVertices.push(project({x:dx*pulseSize+cube.x,y:dy*pulseSize+cube.y,z:dz*pulseSize+cube.z},instance));}for(const edge of edges){drawGlitchyLine(projectedVertices[edge[0]],projectedVertices[edge[1]],instance);}}}

        // ---- Main Animation Loop ----
        function animate() {
            globalTime++;
            const isAudioPlaying = audioContext && !(audio.paused || audio.currentTime === 0 || audio.ended);
            if (isAudioPlaying) analyzeAudio();

            visualizerInstances.forEach(instance => {
                const { ctx, canvas, camera } = instance;
                let target = isAudioPlaying ? 1 : 0;
                instance.modeTransition += (target - instance.modeTransition) * 0.09;
                
                if (isAudioPlaying) {
                    camera.x += Math.sin(globalTime * 0.005 + instance.noiseOffset.x) * 2 * CURRENT_SPEED;
                    camera.y = lerp(camera.y, camera.targetY, 0.05) + Math.sin(globalTime * 0.003) * 50 * CURRENT_SPEED;
                    if (instance.mode === 'lineBox') {
                        camera.z += 5 * CURRENT_SPEED;
                        if (camera.z > 0) camera.z = -800;
                    }
                }
                
                ctx.fillStyle = FOG_COLOR;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                if (instance.modeTransition < 1) drawChillParticles(instance);
                if (instance.modeTransition > 0.01) {
                    ctx.save();
                    ctx.globalAlpha = instance.modeTransition;
                    switch (instance.mode) {
                        case 'lineBox': drawLineBox(instance); break;
                        case 'radialPulse': drawRadialPulse(instance); break;
                        case 'cubeField': drawCubeField(instance); break;
                    }
                    ctx.restore();
                }
            });
            requestAnimationFrame(animate);
        }

        // ---- Event Listeners ----
        window.addEventListener('resize', handleResize);
        audio.addEventListener('play', () => {
             if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        });
        fileInput.addEventListener('change', () => {
            if (fileInput.files.length > 0) {
                audio.src = URL.createObjectURL(fileInput.files[0]);
                audio.load();
                audio.pause();
            }
        });
        speedSlider.addEventListener('input', e => CURRENT_SPEED = e.target.value / 100);
        colorPicker.addEventListener('input', e => {
            BASE_LINE_COLOR = e.target.value;
            IS_RAINBOW_MODE = false;
            rainbowButton.classList.remove('active');
        });
        rainbowButton.addEventListener('click', () => {
            IS_RAINBOW_MODE = !IS_RAINBOW_MODE;
            rainbowButton.classList.toggle('active', IS_RAINBOW_MODE);
        });
        modeSelector.addEventListener('change', e => {
            if (layoutSelector.value === 'single' && visualizerInstances[0]) {
                visualizerInstances[0].mode = e.target.value;
            }
        });
        layoutSelector.addEventListener('change', e => setupVisualizers(e.target.value));

        // ---- Initial Setup ----
        document.body.addEventListener('click', initAudio, { once: true });
        setupVisualizers('single');
        animate();
    </script>
</body>
</html>
