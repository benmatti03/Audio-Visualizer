<!DOCTYPE html>
<html>
<head>
    <title>Audio-Reactive Glitch Visualizer - Optimized Retro Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- General & Core Aesthetics --- */
        :root {
            --neon-green: #00ffc8;
            --dark-background: #000;
            --button-dark: #111;
        }

        body {
            background-color: var(--dark-background);
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
            font-family: 'Space Mono', monospace;
            color: var(--neon-green);
        }
        
        canvas {
            background-color: var(--dark-background);
            cursor: crosshair;
            display: block;
        }

        /* --- UI Container - The Glowing Panel --- */
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 0; /* Sharp corners */
            border: 2px solid var(--neon-green);
            box-shadow: 0 0 15px var(--neon-green), inset 0 0 5px rgba(0, 255, 200, 0.5);
            z-index: 10;
            max-width: 350px;
        }

        .controls h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--neon-green);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 1.2em;
            text-shadow: 0 0 5px var(--neon-green);
        }
        
        .control-group {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        label {
            min-width: 80px;
            text-align: right;
            font-size: 0.9em;
            color: #ccc;
        }

        /* --- Sliders --- */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: rgba(0, 255, 200, 0.2);
            border: 1px solid var(--neon-green);
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
            border-radius: 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--neon-green);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 5px var(--neon-green);
        }
        
        /* --- Color Picker --- */
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 40px;
            height: 40px;
            background: transparent;
            cursor: pointer;
            padding: 0;
        }
        
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        
        input[type="color"]::-webkit-color-swatch {
            border: 2px solid var(--neon-green);
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 255, 200, 0.5);
        }
        
        /* --- Buttons --- */
        button {
            background-color: var(--button-dark);
            color: var(--neon-green);
            border: 1px solid var(--neon-green);
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: background-color 0.1s, color 0.1s, box-shadow 0.1s;
            font-family: 'Space Mono', monospace;
            box-shadow: 0 0 5px rgba(0, 255, 200, 0.5);
        }
        
        button:hover {
            background-color: var(--neon-green);
            color: var(--button-dark);
            box-shadow: 0 0 15px var(--neon-green);
        }
        
        #rainbowButton.active {
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            color: var(--dark-background);
            font-weight: bold;
            border: none;
            box-shadow: 0 0 10px var(--neon-green);
        }
        
        /* --- Audio Player and Separator --- */
        hr {
            border: none;
            border-top: 1px dashed #555;
            margin: 15px 0;
        }

        audio {
            width: 100%;
            margin-top: 15px;
            /* Filter to change the audio player's color to green/dark */
            filter: invert(1) sepia(1) saturate(5) hue-rotate(100deg);
        }

        .intro-message {
            position: absolute;
            text-align: center;
            color: var(--neon-green);
            font-family: 'Space Mono', monospace;
            font-size: 1.5em;
            padding: 20px;
            text-shadow: 0 0 5px var(--neon-green);
            transition: opacity 1s;
            pointer-events: none;
        }

    </style>
</head>
<body>
    <div class="controls">
        <h2>System Controls</h2>
        
        <div class="control-group">
            <label for="speedSlider">Speed:</label>
            <input type="range" id="speedSlider" min="1" max="100" value="20">
        </div>
        
        <div class="control-group">
            <label for="colorPicker">Line Color:</label>
            <input type="color" id="colorPicker" value="#00ffc8">
        </div>
        
        <div class="control-group">
            <button id="rainbowButton">ðŸŒˆ Cycle Color</button>
        </div>
        
        <hr>
        
        <h2>Audio Source</h2>
        <input type="file" id="audioFile" class="audio-upload" accept="audio/*" />
        <audio id="audioPlayer" controls loop>
            <source src="song.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
        </audio>
    </div>

    <canvas id="glitchCanvas"></canvas>
    
    <div class="intro-message">
        INITIATE VISUALIZER: PRESS PLAY OR UPLOAD AUDIO
    </div>

    <script>
        // ---- DOM elements ----
        const canvas = document.getElementById('glitchCanvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('audioPlayer');
        const fileInput = document.getElementById('audioFile');
        const speedSlider = document.getElementById('speedSlider');
        const colorPicker = document.getElementById('colorPicker');
        const rainbowButton = document.getElementById('rainbowButton');
        const introMessage = document.querySelector('.intro-message');

        // ---- Performance constants/variables (Optimized) ----
        let GRID_SIZE = 32;
        const CELL_SIZE = 120;
        const MAX_Z_DEFORMATION = 350;
        const NOISE_SCALE = 0.02;
        const GLITCH_INTENSITY = 10;
        const FOG_COLOR = 'rgba(0, 0, 0, 0.10)';
        const MAX_LINE_SEGMENTS = 5;
        const FPS_TARGET = 30; // Target FPS for performance scaling
        const FPS_DEGRADE_THRESHOLD = FPS_TARGET - 5; 
        const FPS_IMPROVE_THRESHOLD = FPS_TARGET + 5; 
        const GRID_REDUCTION_FACTOR = 0.8; // Reduce grid size by 20%
        const BASE_GRID_SIZE = 32;

        let BASE_LINE_COLOR = colorPicker.value;
        let CURRENT_SPEED = speedSlider.value / 100;
        let IS_RAINBOW_MODE = false;

        // ---- Audio ----
        let audioContext;
        let analyser;
        // Optimized FFT_SIZE for smoother analysis vs. detail
        const FFT_SIZE = 512; 
        let frequencyData;
        let bassEnergy = 0;
        let midHighEnergy = 0;
        let mediaElementSource = null;

        // ---- Camera/3D ----
        const camera = { x: 0, y: 150, z: -800, fov: 600, targetY: 0 };
        let points = [];
        let noiseOffset = { x: 0, y: 0 };
        let globalTime = 0;

        // ---- Transition & FPS ----
        let visualizerActive = false;
        let modeTransition = 0;
        let frameCount = 0, fps = 60, fpsSampleStart = performance.now();
        let gridDetailReduced = false;
        let pendingGridResize = null;

        // ---- Chill Mode ----
        let chillParticles = [];
        const CHILL_PARTICLE_COUNT = 55;
        function spawnChillParticles() {
            chillParticles = [];
            for (let i = 0; i < CHILL_PARTICLE_COUNT; i++) {
                chillParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    r: 20 + Math.random() * 25,
                    opacity: 0.09 + Math.random() * 0.15,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    pulse: 0,
                    pulseSpeed: 0.01 + Math.random() * 0.01,
                    baseR: 20 + Math.random() * 25
                });
            }
        }

        // ---- Audio Setup (Init on interaction) ----
        function initAudio() {
            try {
                if (audioContext && audioContext.state !== "closed") {
                     // Clean up old source if context exists
                     if (mediaElementSource) {
                        mediaElementSource.disconnect();
                        mediaElementSource = null;
                    }
                } else {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                analyser = audioContext.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                // Pre-allocating buffer for performance
                frequencyData = new Uint8Array(analyser.frequencyBinCount); 
                
                mediaElementSource = audioContext.createMediaElementSource(audio);
                mediaElementSource.connect(analyser);
                analyser.connect(audioContext.destination);
            } catch (e) {
                console.error("Audio Context initialization failed:", e);
                analyser = null;
            }
        }

        audio.addEventListener('play', () => {
            if (!analyser) { // Only initialize on the first play or if needed
                initAudio();
            } else if (audioContext.state === "suspended") {
                audioContext.resume();
            }
            visualizerActive = true;
            if (introMessage) {
                introMessage.style.opacity = '0';
            }
        });
        audio.addEventListener('pause', () => { visualizerActive = false; });
        audio.addEventListener('ended', () => { visualizerActive = false; });

        // ---- Audio File Upload ----
        fileInput.addEventListener('change', function() {
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const url = URL.createObjectURL(file);
                audio.src = url;
                audio.load();
                visualizerActive = false;
            }
        });

        // ---- Utility Functions (Optimized/Pre-existing math logic) ----
        function hexToRgbA(hex, alpha) {
            let r = parseInt(hex.substring(1, 3), 16);
            let g = parseInt(hex.substring(3, 5), 16);
            let b = parseInt(hex.substring(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        // [hsvToRgb, lerp, fade, perlinNoise logic is kept as is, as it's fundamental to the effect]
        function hsvToRgb(h, s, v) {
            let r, g, b, i, f, p, q, t;
            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return '#' + (Math.round(r * 255)).toString(16).padStart(2, '0') +
                         (Math.round(g * 255)).toString(16).padStart(2, '0') +
                         (Math.round(b * 255)).toString(16).padStart(2, '0');
        }
        function lerp(a, b, t) { return a + t * (b - a); }
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        
        const permutation = new Array(512);
        const p = new Array(256);
        for (let i = 0; i < 256; i++) { p[i] = Math.floor(Math.random() * 256); }
        for (let i = 0; i < 512; i++) { permutation[i] = p[i & 255]; }
        function grad(hash, x, y, z) {
            switch (hash & 0xF) {
                case 0x0: return x + y; case 0x1: return -x + y; case 0x2: return x - y;
                case 0x3: return -x - y; case 0x4: return x + z; case 0x5: return -x + z;
                case 0x6: return x - z; case 0x7: return -x - z; case 0x8: return y + z;
                case 0x9: return -y + z; case 0xA: return y - z; case 0xB: return -y - z;
                case 0xC: return y + x; case 0xD: return -y + z; case 0xE: return y - x;
                case 0xF: return -y - z; default: return 0;
            }
        }
        function perlinNoise(x, y, z) {
            let X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
            x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
            let u = fade(x), v = fade(y), w = fade(z);
            let A = permutation[X] + Y, AA = permutation[A] + Z, AB = permutation[A + 1] + Z;
            let B = permutation[X + 1] + Y, BA = permutation[B] + Z, BB = permutation[B + 1] + Z;
            return lerp(w, lerp(v, lerp(u, grad(permutation[AA], x, y, z), grad(permutation[BA], x - 1, y, z)),
                lerp(u, grad(permutation[AB], x, y - 1, z), grad(permutation[BB], x - 1, y - 1, z))),
                lerp(v, lerp(u, grad(permutation[AA + 1], x, y, z - 1), grad(permutation[BA + 1], x - 1, y, z - 1)),
                lerp(u, grad(permutation[AB + 1], x, y - 1, z - 1), grad(permutation[BB + 1], x - 1, y - 1, z - 1))));
        }

        // ---- 3D Point and Grid ----
        class Point3D {
            constructor(x, y, z) {
                this.x = x; this.y = y; this.z = z;
            }
        }
        function initGrid() {
            points = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                points.push([]);
                const x3D_base = (i - GRID_SIZE / 2) * CELL_SIZE; // Pre-calculate x part
                for (let j = 0; j < GRID_SIZE; j++) {
                    let y3D = (j - GRID_SIZE / 2) * CELL_SIZE;
                    points[i].push(new Point3D(x3D_base, y3D, 0));
                }
            }
        }
        function project(p3d) {
            const tz = p3d.z - camera.z;
            const scale = camera.fov / (camera.fov + tz);
            // Using fast Math.round/bitwise OR for potential micro-optimization on coordinates
            const x2d = (p3d.x - camera.x) * scale + canvas.width / 2;
            const y2d = (p3d.y - camera.y) * scale + canvas.height / 2;
            return { x: x2d | 0, y: y2d | 0, scale: scale, depth: tz };
        }

        function drawGlitchyLine(p1, p2, scale, alpha = 1.0) {
            ctx.lineWidth = Math.max(0.25, 1 / (1 + p1.depth * 0.002));
            if (ctx.lineWidth < 0.2) return;

            let colorToUse = IS_RAINBOW_MODE ? hsvToRgb(globalTime * 0.0001 % 1, 1, 1) : BASE_LINE_COLOR;
            let opacity = Math.max(0.1, 1 - Math.abs(p1.depth) / 1500);
            const strokeStyle = hexToRgbA(colorToUse, opacity * alpha);
            
            // Set style once per line draw call
            ctx.strokeStyle = strokeStyle;
            ctx.shadowColor = colorToUse;
            ctx.shadowBlur = Math.min(5, 3 * opacity); // Cap shadow blur

            let startX = p1.x; let startY = p1.y; let endX = p2.x; let endY = p2.y;
            
            // Optimized segment calculation: Use a fixed small number of segments
            const numSegments = 3; 

            ctx.beginPath();
            for (let i = 0; i < numSegments; i++) {
                let segStartX = lerp(startX, endX, i / numSegments);
                let segStartY = lerp(startY, endY, i / numSegments);
                let segEndX = lerp(startX, endX, (i + 1) / numSegments);
                let segEndY = lerp(startY, endY, (i + 1) / numSegments);

                // Reduce expensive Math.random calls by applying jitter only to segment endpoints
                let jitterFactor = GLITCH_INTENSITY + midHighEnergy / 10;
                let scaleFactor = 1 - scale;
                if (gridDetailReduced) jitterFactor *= 0.5;

                segStartX += (Math.random() - 0.5) * jitterFactor * scaleFactor;
                segStartY += (Math.random() - 0.5) * jitterFactor * scaleFactor;
                segEndX += (Math.random() - 0.5) * jitterFactor * scaleFactor;
                segEndY += (Math.random() - 0.5) * jitterFactor * scaleFactor;

                if (i === 0) {
                    ctx.moveTo(segStartX, segStartY);
                } else {
                    ctx.lineTo(segStartX, segStartY); // Draw to the new jittered start point
                }
                ctx.lineTo(segEndX, segEndY);
            }
            ctx.stroke();
            ctx.shadowBlur = 0; // Turn off shadow after drawing lines
        }

        // ---- Audio Analysis (Smoothed and Optimized) ----
        function analyzeAudio() {
            if (!analyser || audio.paused || audio.ended || !frequencyData) {
                bassEnergy = 0; midHighEnergy = 0; return;
            }
            // Use time domain data for slightly different visual
            analyser.getByteFrequencyData(frequencyData); 

            let currentBass = 0, currentMidHigh = 0;
            const bassBins = Math.max(1, Math.floor(FFT_SIZE / 16)); // More accurate bass range
            
            // Calculate Bass Sum
            for (let i = 0; i < bassBins; i++) currentBass += frequencyData[i];
            
            // Calculate Mid/High Sum (higher frequency detail for glitch)
            const midHighStart = Math.floor(FFT_SIZE * 0.4); 
            for (let i = midHighStart; i < FFT_SIZE / 2; i++) currentMidHigh += frequencyData[i];

            const bassAvg = currentBass / bassBins / 255;
            const midHighAvg = currentMidHigh / (FFT_SIZE / 2 - midHighStart) / 255;

            // Smoothed update for less jarring transitions (Optimization)
            bassEnergy = lerp(bassEnergy, bassAvg * 0.85, 0.15); 
            midHighEnergy = lerp(midHighEnergy, midHighAvg * 0.85, 0.15); 

            // Guard against NaN
            if (isNaN(bassEnergy) || !isFinite(bassEnergy)) bassEnergy = 0;
            if (isNaN(midHighEnergy) || !isFinite(midHighEnergy)) midHighEnergy = 0;
        }

        // ---- Chill/Transition Drawing ----
        function drawChillParticles(alpha = 1.0) {
            ctx.save();
            ctx.globalAlpha = alpha * 0.8;
            ctx.filter = 'blur(2px)'; // Apply subtle blur to chill particles (Aesthetic Optimization)
            for (let i = 0; i < chillParticles.length; i++) {
                const p = chillParticles[i];
                p.pulse += p.pulseSpeed;
                let pulseR = p.baseR + Math.sin(p.pulse) * 5 + (Math.random() - 0.5) * 3;
                p.x += p.vx; p.y += p.vy;
                
                if (p.x > canvas.width) p.x = 0;
                if (p.x < 0) p.x = canvas.width;
                if (p.y > canvas.height) p.y = 0;
                if (p.y < 0) p.y = canvas.height;
                
                const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, pulseR);
                grad.addColorStop(0, `rgba(255,0,255,${p.opacity})`);
                grad.addColorStop(1, `rgba(0,0,0,0)`);
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, pulseR, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
            }
            ctx.filter = 'none';
            ctx.restore();
        }

        // ---- Main Draw ----
        function draw() {
            // Use opaque black fill for better performance before transparent fog (Optimization)
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = FOG_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let target = (visualizerActive && !(audio.paused || audio.currentTime === 0 || audio.ended)) ? 1 : 0;
            // More aggressive transition for a snappier feel
            modeTransition += (target - modeTransition) * 0.15; 
            modeTransition = Math.max(0, Math.min(1, modeTransition));

            if (modeTransition < 0.98) drawChillParticles(1 - modeTransition);

            if (modeTransition > 0.02) {
                analyzeAudio();
                const noiseZInput = globalTime * CURRENT_SPEED * 0.05 + bassEnergy * 5;
                
                // Pre-calculating the impact variables outside the inner loops
                const noiseScale = NOISE_SCALE;
                const maxZDeformation = MAX_Z_DEFORMATION;
                const audioImpact = bassEnergy * maxZDeformation * 2;

                for (let i = 0; i < points.length; i++) {
                    const column = points[i];
                    for (let j = 0; j < column.length; j++) {
                        let p = column[j];
                        // Faster calculation using pre-calculated noise scale
                        const baseZ = perlinNoise(
                            (p.x + noiseOffset.x) * noiseScale,
                            (p.y + noiseOffset.y) * noiseScale,
                            noiseZInput
                        ) * maxZDeformation;
                        p.z = baseZ + audioImpact;
                    }
                }
                
                ctx.save();
                ctx.globalAlpha = modeTransition;
                for (let i = 0; i < points.length; i++) {
                    for (let j = 0; j < points[i].length; j++) {
                        let p1 = project(points[i][j]);
                        if (j < points[i].length - 1) {
                            let p2 = project(points[i][j + 1]);
                            drawGlitchyLine(p1, p2, p1.scale, 1.0);
                        }
                        if (i < points.length - 1 && points[i + 1]) {
                            let p2 = project(points[i + 1][j]);
                            drawGlitchyLine(p1, p2, p1.scale, 1.0);
                        }
                    }
                }
                ctx.restore();
            }
        }

        // ---- Animation Loop (Optimization on FPS logic) ----
        function animate() {
            try {
                globalTime++;

                // Camera movement: only update when active
                if (visualizerActive) {
                    const forwardSpeed = 5 * CURRENT_SPEED;
                    camera.x += Math.sin(globalTime * 0.005) * 2 * CURRENT_SPEED;
                    camera.y = lerp(camera.y, camera.targetY + Math.sin(globalTime * 0.003) * 50 * CURRENT_SPEED, 0.05); // Smoothed Y movement
                    camera.z += forwardSpeed;
                    if (camera.z > 0) camera.z = -800;
                }

                // Defer grid resize to start of frame
                if (pendingGridResize !== null) {
                    GRID_SIZE = pendingGridResize;
                    initGrid();
                    pendingGridResize = null;
                }

                draw();
                
                // FPS/performance check every 1 second
                frameCount++;
                let now = performance.now();
                if (now - fpsSampleStart > 1000) {
                    fps = frameCount / ((now - fpsSampleStart) / 1000);
                    frameCount = 0;
                    fpsSampleStart = now;
                    
                    // Adaptive Grid Logic (Optimization)
                    if (fps < FPS_DEGRADE_THRESHOLD && !gridDetailReduced) {
                        // FPS is too low, reduce grid size
                        pendingGridResize = Math.max(18, Math.floor(GRID_SIZE * GRID_REDUCTION_FACTOR));
                        gridDetailReduced = true;
                    } else if (fps > FPS_IMPROVE_THRESHOLD && gridDetailReduced) {
                        // FPS is high enough, restore grid size to base
                        pendingGridResize = BASE_GRID_SIZE;
                        gridDetailReduced = false;
                    }
                }

                requestAnimationFrame(animate);
            } catch (err) {
                // Display error overlay for debugging
                ctx.save();
                ctx.fillStyle = "rgba(255,0,0,0.7)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#fff";
                ctx.font = "20px monospace";
                ctx.fillText("JS Error: " + err.message, 50, 80);
                ctx.restore();
                console.error(err);
            }
        }

        // ---- Inputs (No change needed) ----
        speedSlider.addEventListener('input', (e) => {
            CURRENT_SPEED = e.target.value / 100;
        });
        colorPicker.addEventListener('input', (e) => {
            BASE_LINE_COLOR = e.target.value;
            IS_RAINBOW_MODE = false;
            rainbowButton.classList.remove('active');
        });
        rainbowButton.addEventListener('click', () => {
            IS_RAINBOW_MODE = !IS_RAINBOW_MODE;
            rainbowButton.classList.toggle('active', IS_RAINBOW_MODE);
        });
        canvas.addEventListener('click', () => {
            noiseOffset.x += (Math.random() * 1000 - 500) * (1 + bassEnergy * 4);
            noiseOffset.y += (Math.random() * 1000 - 500) * (1 + bassEnergy * 4);
            camera.targetY = (Math.random() - 0.5) * 300;
        });
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth * 0.95;
            canvas.height = window.innerHeight * 0.95;
            initGrid();
            spawnChillParticles();
        });

        // ---- Initial setup ----
        canvas.width = window.innerWidth * 0.95;
        canvas.height = window.innerHeight * 0.95;
        initGrid();
        spawnChillParticles();
        animate();
    </script>
</body>
</html>
