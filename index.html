<!DOCTYPE html>
<html>
<head>
    <title>Audio-Reactive Glitch Visualizer</title>
    <style>
        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }
        canvas {
            background-color: #000;
            cursor: pointer;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: #fff;
            font-family: monospace;
            z-index: 10;
        }
        .control-group {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            width: 80px;
            text-align: right;
        }
        button {
            background-color: #555;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }
        #rainbowButton.active {
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            color: black;
            font-weight: bold;
        }
        .audio-upload {
            margin-top: 10px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>

    <div class="controls">
        <h2>Visualizer Controls</h2>
        
        <div class="control-group">
            <label for="speedSlider">Speed:</label>
            <input type="range" id="speedSlider" min="1" max="50" value="20">
        </div>
        <div class="control-group">
            <label for="colorPicker">Color:</label>
            <input type="color" id="colorPicker" value="#00ffc8">
        </div>
        <div class="control-group">
            <button id="rainbowButton">ðŸŒˆ Rainbow Mode</button>
        </div>

        <hr style="border-color:#333; margin: 10px 0;">

        <h2>Audio Player (Upload or Use Default)</h2>
        <input type="file" id="audioFile" class="audio-upload" accept="audio/*" />
        <audio id="audioPlayer" controls loop>
            <source src="song.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
        </audio>
    </div>

    <canvas id="glitchCanvas"></canvas>

    <script>
        const canvas = document.getElementById('glitchCanvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('audioPlayer');
        const fileInput = document.getElementById('audioFile');

        // Control Elements
        const speedSlider = document.getElementById('speedSlider');
        const colorPicker = document.getElementById('colorPicker');
        const rainbowButton = document.getElementById('rainbowButton');

        canvas.width = window.innerWidth * 0.95;
        canvas.height = window.innerHeight * 0.95;

        // --- Visualization Configuration ---
        const GRID_SIZE = 40; 
        const CELL_SIZE = 120; 
        const MAX_Z_DEFORMATION = 350;
        const NOISE_SCALE = 0.02; 
        const GLITCH_INTENSITY = 10; 
        const FOG_COLOR = 'rgba(0, 0, 0, 0.1)'; 

        // Live-Updated Variables
        let BASE_LINE_COLOR = colorPicker.value;
        let CURRENT_SPEED = speedSlider.value / 100;
        let IS_RAINBOW_MODE = false;

        // --- Audio Analysis Variables ---
        let audioContext;
        let analyser;
        let frequencyData;
        const FFT_SIZE = 256;
        let bassEnergy = 0;
        let midHighEnergy = 0;

        // --- Camera & 3D Variables ---
        const camera = {
            x: 0, y: 150, z: -800, 
            fov: 600, 
            targetY: 0 
        };
        let points = []; 
        let noiseOffset = { x: 0, y: 0 }; 
        let globalTime = 0;

        // --- Chill Mode Variables ---
        let chillParticles = [];
        const CHILL_PARTICLE_COUNT = 55;
        function spawnChillParticles() {
            chillParticles = [];
            for (let i = 0; i < CHILL_PARTICLE_COUNT; i++) {
                chillParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    r: 20 + Math.random() * 25,
                    opacity: 0.09 + Math.random() * 0.15,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    pulse: 0,
                    pulseSpeed: 0.01 + Math.random() * 0.01,
                    baseR: 20 + Math.random() * 25
                });
            }
        }

        // --- Initialization and Audio Setup ---
        function initAudio() {
            if (audioContext) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = FFT_SIZE;
            frequencyData = new Uint8Array(analyser.frequencyBinCount);
            const source = audioContext.createMediaElementSource(audio);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
        }

        audio.addEventListener('play', () => {
            // Always re-init and connect to destination
            if (!audioContext || audioContext.state === "closed") {
                initAudio();
            } else if (audioContext.state === "suspended") {
                audioContext.resume();
            }
        });

        // Handle audio file uploads
        fileInput.addEventListener('change', function() {
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const url = URL.createObjectURL(file);
                audio.src = url;
                audio.load();
                audio.play();
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }
            }
        });

        function hexToRgbA(hex, alpha) {
            let r = parseInt(hex.substring(1, 3), 16);
            let g = parseInt(hex.substring(3, 5), 16);
            let b = parseInt(hex.substring(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        function hsvToRgb(h, s, v) {
            let r, g, b, i, f, p, q, t;
            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return '#' + (Math.round(r * 255)).toString(16).padStart(2, '0') + 
                         (Math.round(g * 255)).toString(16).padStart(2, '0') + 
                         (Math.round(b * 255)).toString(16).padStart(2, '0');
        }
        function lerp(a, b, t) { return a + t * (b - a); }
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        const permutation = new Array(512);
        const p = new Array(256);
        for (let i = 0; i < 256; i++) { p[i] = Math.floor(Math.random() * 256); }
        for (let i = 0; i < 512; i++) { permutation[i] = p[i & 255]; }
        function grad(hash, x, y, z) {
            switch (hash & 0xF) {
                case 0x0: return x + y; case 0x1: return -x + y; case 0x2: return x - y;
                case 0x3: return -x - y; case 0x4: return x + z; case 0x5: return -x + z;
                case 0x6: return x - z; case 0x7: return -x - z; case 0x8: return y + z;
                case 0x9: return -y + z; case 0xA: return y - z; case 0xB: return -y - z;
                case 0xC: return y + x; case 0xD: return -y + z; case 0xE: return y - x;
                case 0xF: return -y - z; default: return 0; 
            }
        }
        function perlinNoise(x, y, z) {
            let X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
            x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
            let u = fade(x), v = fade(y), w = fade(z);
            let A = permutation[X] + Y, AA = permutation[A] + Z, AB = permutation[A + 1] + Z;
            let B = permutation[X + 1] + Y, BA = permutation[B] + Z, BB = permutation[B + 1] + Z;
            return lerp(w, lerp(v, lerp(u, grad(permutation[AA], x, y, z), grad(permutation[BA], x - 1, y, z)), lerp(u, grad(permutation[AB], x, y - 1, z), grad(permutation[BB], x - 1, y - 1, z))),
                        lerp(v, lerp(u, grad(permutation[AA + 1], x, y, z - 1), grad(permutation[BA + 1], x - 1, y, z - 1)), lerp(u, grad(permutation[AB + 1], x, y - 1, z - 1), grad(permutation[BB + 1], x - 1, y - 1, z - 1))));
        }

        // --- 3D Point Structure and Grid Init ---
        class Point3D {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
        }

        function initGrid() {
            points = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                points.push([]);
                for (let j = 0; j < GRID_SIZE; j++) {
                    let x3D = (i - GRID_SIZE / 2) * CELL_SIZE;
                    let y3D = (j - GRID_SIZE / 2) * CELL_SIZE;
                    points[i].push(new Point3D(x3D, y3D, 0));
                }
            }
        }

        // --- Project 3D to 2D ---
        function project(p3d) {
            let tx = p3d.x - camera.x;
            let ty = p3d.y - camera.y;
            let tz = p3d.z - camera.z;

            let scale = camera.fov / (camera.fov + tz);
            let x2d = tx * scale + canvas.width / 2;
            let y2d = ty * scale + canvas.height / 2;

            return { x: x2d, y: y2d, scale: scale, depth: tz };
        }

        // --- Glitchy Line Drawing Function ---
        function drawGlitchyLine(p1, p2, scale) {
            ctx.lineWidth = (1 / (1 + p1.depth * 0.002));
            if (ctx.lineWidth < 0.2) return; 

            let colorToUse = IS_RAINBOW_MODE ? hsvToRgb(globalTime * 0.0001 % 1, 1, 1) : BASE_LINE_COLOR;
            let opacity = Math.max(0.1, 1 - Math.abs(p1.depth) / 1500);
            ctx.strokeStyle = hexToRgbA(colorToUse, opacity);

            let startX = p1.x;
            let startY = p1.y;
            let endX = p2.x;
            let endY = p2.y;

            const numSegments = Math.max(2, Math.floor(Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)) / 20)); 

            for (let i = 0; i < numSegments; i++) {
                let segStartX = lerp(startX, endX, i / numSegments);
                let segStartY = lerp(startY, endY, i / numSegments);
                let segEndX = lerp(startX, endX, (i + 1) / numSegments);
                let segEndY = lerp(startY, endY, (i + 1) / numSegments);

                // Jitter based on high-frequency energy (glitch on high notes)
                let jitterFactor = GLITCH_INTENSITY + midHighEnergy / 10;
                let scaleFactor = 1 - scale;
                
                segStartX += (Math.random() - 0.5) * jitterFactor * scaleFactor;
                segStartY += (Math.random() - 0.5) * jitterFactor * scaleFactor;
                segEndX += (Math.random() - 0.5) * jitterFactor * scaleFactor;
                segEndY += (Math.random() - 0.5) * jitterFactor * scaleFactor;

                ctx.beginPath();
                ctx.moveTo(segStartX, segStartY);
                ctx.lineTo(segEndX, segEndY);
                ctx.stroke();
            }
        }

        // --- Audio Processing Loop ---
        function analyzeAudio() {
            if (!analyser || audio.paused) {
                bassEnergy = 0;
                midHighEnergy = 0;
                return;
            }
            analyser.getByteFrequencyData(frequencyData);

            let bassSum = 0;
            let midHighSum = 0;

            // Calculate Bass (low frequencies, e.g., first 5-10 bins)
            const bassBins = Math.floor(FFT_SIZE / 12);
            for (let i = 0; i < bassBins; i++) {
                bassSum += frequencyData[i];
            }
            // Calculate Mid/High (higher frequencies, e.g., upper 1/4 of bins)
            const midHighStart = Math.floor(FFT_SIZE * 0.75);
            for (let i = midHighStart; i < FFT_SIZE / 2; i++) {
                midHighSum += frequencyData[i];
            }

            // Normalize and smooth the values
            bassEnergy = bassSum / bassBins / 255;
            midHighEnergy = midHighSum / (FFT_SIZE / 2 - midHighStart) / 255;
            bassEnergy *= 0.85;
            midHighEnergy *= 0.85; 
        }

        // --- Chill Visuals ---
        function drawChillParticles() {
            for (let i = 0; i < chillParticles.length; i++) {
                const p = chillParticles[i];
                // Pulsing radius
                p.pulse += p.pulseSpeed;
                let pulseR = p.baseR + Math.sin(p.pulse) * 3 + (Math.random() - 0.5) * 2;
                // Update position (very slow drifting)
                p.x += p.vx;
                p.y += p.vy;
                // Wrap around
                if (p.x > canvas.width) p.x = 0;
                if (p.x < 0) p.x = canvas.width;
                if (p.y > canvas.height) p.y = 0;
                if (p.y < 0) p.y = canvas.height;
                // Soft white glow
                const grad = ctx.createRadialGradient(
                    p.x, p.y, 0,
                    p.x, p.y, pulseR
                );
                grad.addColorStop(0, `rgba(255,255,255,${p.opacity})`);
                grad.addColorStop(1, `rgba(255,255,255,0)`);
                ctx.beginPath();
                ctx.arc(p.x, p.y, pulseR, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
            }
        }

        // --- Main Drawing Logic ---
        function draw() {
            ctx.fillStyle = FOG_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (audio.paused || audio.currentTime === 0) {
                // Chill Mode: No grid, just floating soft white particles
                drawChillParticles();
                return;
            }

            analyzeAudio();

            // 1. Update Z-values based on NOISE and BASS ENERGY
            const noiseZInput = globalTime * CURRENT_SPEED * 0.05 + bassEnergy * 5;
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    let p = points[i][j];
                    const baseZ = perlinNoise(
                        (p.x + noiseOffset.x) * NOISE_SCALE,
                        (p.y + noiseOffset.y) * NOISE_SCALE,
                        noiseZInput
                    ) * MAX_Z_DEFORMATION;
                    const audioImpact = bassEnergy * MAX_Z_DEFORMATION * 2; 
                    p.z = baseZ + audioImpact;
                }
            }

            // 2. Draw grid lines
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    let p1 = project(points[i][j]);
                    if (j < GRID_SIZE - 1) {
                        let p2 = project(points[i][j+1]);
                        drawGlitchyLine(p1, p2, p1.scale);
                    }
                    if (i < GRID_SIZE - 1) {
                        let p2 = project(points[i+1][j]);
                        drawGlitchyLine(p1, p2, p1.scale);
                    }
                }
            }
        }

        // --- Animation Loop ---
        function animate() {
            globalTime++;
            // Camera Movement (Uses speed for camera forward motion)
            if (!(audio.paused || audio.currentTime === 0)) {
                const forwardSpeed = 5 * CURRENT_SPEED;
                camera.x += Math.sin(globalTime * 0.005) * 2 * CURRENT_SPEED;
                camera.y = camera.targetY + Math.sin(globalTime * 0.003) * 50 * CURRENT_SPEED;
                camera.z += forwardSpeed; 
                if (camera.z > 0) camera.z = -800; 
            }
            draw();
            requestAnimationFrame(animate);
        }

        // --- Input Event Handlers ---
        speedSlider.addEventListener('input', (e) => {
            CURRENT_SPEED = e.target.value / 100;
        });

        colorPicker.addEventListener('input', (e) => {
            BASE_LINE_COLOR = e.target.value;
            IS_RAINBOW_MODE = false;
            rainbowButton.classList.remove('active');
        });

        rainbowButton.addEventListener('click', () => {
            IS_RAINBOW_MODE = !IS_RAINBOW_MODE;
            rainbowButton.classList.toggle('active', IS_RAINBOW_MODE);
        });

        canvas.addEventListener('click', () => {
            noiseOffset.x += (Math.random() * 1000 - 500) * (1 + bassEnergy * 2);
            noiseOffset.y += (Math.random() * 1000 - 500) * (1 + bassEnergy * 2);
            camera.targetY = (Math.random() - 0.5) * 300; 
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth * 0.95;
            canvas.height = window.innerHeight * 0.95;
            initGrid();
            spawnChillParticles();
        });

        // Initializations
        initGrid();
        spawnChillParticles();
        animate();
    </script>
</body>
</html>
