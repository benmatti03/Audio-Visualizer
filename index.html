<!DOCTYPE html>
<html>
<head>
    <title>Audio-Reactive Glitch Visualizer</title>
    <style>
        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }
        canvas {
            background-color: #000;
            cursor: pointer;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: #fff;
            font-family: monospace;
            z-index: 10;
        }
        .control-group {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            width: 80px;
            text-align: right;
        }
        button {
            background-color: #555;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }
        #rainbowButton.active {
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            color: black;
            font-weight: bold;
        }
        .audio-upload {
            margin-top: 10px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h2>Visualizer Controls</h2>
        <div class="control-group">
            <label for="speedSlider">Speed:</label>
            <input type="range" id="speedSlider" min="1" max="50" value="20">
        </div>
        <div class="control-group">
            <label for="colorPicker">Color:</label>
            <input type="color" id="colorPicker" value="#00ffc8">
        </div>
        <div class="control-group">
            <button id="rainbowButton">ðŸŒˆ Rainbow Mode</button>
        </div>
        <hr style="border-color:#333; margin: 10px 0;">
        <h2>Audio Player (Upload or Use Default)</h2>
        <input type="file" id="audioFile" class="audio-upload" accept="audio/*" />
        <audio id="audioPlayer" controls loop>
            <source src="song.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
        </audio>
    </div>
    <canvas id="glitchCanvas"></canvas>
    <script>
        // ---- DOM elements ----
        const canvas = document.getElementById('glitchCanvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('audioPlayer');
        const fileInput = document.getElementById('audioFile');
        const speedSlider = document.getElementById('speedSlider');
        const colorPicker = document.getElementById('colorPicker');
        const rainbowButton = document.getElementById('rainbowButton');

        // ---- Parameters ----
        let GRID_SIZE = 32;
        const CELL_SIZE = 120;
        const MAX_Z_DEFORMATION = 350;
        const NOISE_SCALE = 0.02;
        const GLITCH_INTENSITY = 10;
        const FOG_COLOR = 'rgba(0, 0, 0, 0.10)';
        const MAX_LINE_SEGMENTS = 5;

        let BASE_LINE_COLOR = colorPicker.value;
        let CURRENT_SPEED = speedSlider.value / 100;
        let IS_RAINBOW_MODE = false;

        // ---- Audio ----
        let audioContext;
        let analyser;
        let frequencyData;
        const FFT_SIZE = 256;
        let bassEnergy = 0;
        let midHighEnergy = 0;
        let mediaElementSource = null;

        // ---- Camera/3D ----
        const camera = { x: 0, y: 150, z: -800, fov: 600, targetY: 0 };
        let points = [];
        let noiseOffset = { x: 0, y: 0 };
        let globalTime = 0;

        // ---- Transition ----
        let visualizerActive = false;
        let modeTransition = 0;

        // ---- FPS/Performance ----
        let lastFrameTime = performance.now();
        let frameCount = 0, fps = 60, fpsSampleStart = lastFrameTime;
        let gridDetailReduced = false;
        let pendingGridResize = null;

        // ---- Chill Mode ----
        let chillParticles = [];
        const CHILL_PARTICLE_COUNT = 55;
        function spawnChillParticles() {
            chillParticles = [];
            for (let i = 0; i < CHILL_PARTICLE_COUNT; i++) {
                chillParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    r: 20 + Math.random() * 25,
                    opacity: 0.09 + Math.random() * 0.15,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    pulse: 0,
                    pulseSpeed: 0.01 + Math.random() * 0.01,
                    baseR: 20 + Math.random() * 25
                });
            }
        }

        // ---- Audio Setup ----
        function initAudio() {
            try {
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
                if (mediaElementSource) {
                    mediaElementSource.disconnect();
                    mediaElementSource = null;
                }
                mediaElementSource = audioContext.createMediaElementSource(audio);
                mediaElementSource.connect(analyser);
                analyser.connect(audioContext.destination);
            } catch (e) {
                // Prevent crash on repeated context creation
                analyser = null;
            }
        }

        audio.addEventListener('play', () => {
            if (!audioContext || audioContext.state === "closed") {
                initAudio();
            } else if (audioContext.state === "suspended") {
                audioContext.resume();
            }
            visualizerActive = true;
        });
        audio.addEventListener('pause', () => { visualizerActive = false; });
        audio.addEventListener('ended', () => { visualizerActive = false; });

        // ---- Audio File Upload ----
        fileInput.addEventListener('change', function() {
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const url = URL.createObjectURL(file);
                audio.src = url;
                audio.load();
                visualizerActive = false; // Reset
                // Do NOT auto-play, just wait for user to press play
                // When user presses play, the audio event listener will trigger initAudio
            }
        });

        // ---- Utility Functions ----
        function hexToRgbA(hex, alpha) {
            let r = parseInt(hex.substring(1, 3), 16);
            let g = parseInt(hex.substring(3, 5), 16);
            let b = parseInt(hex.substring(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        function hsvToRgb(h, s, v) {
            let r, g, b, i, f, p, q, t;
            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return '#' + (Math.round(r * 255)).toString(16).padStart(2, '0') +
                         (Math.round(g * 255)).toString(16).padStart(2, '0') +
                         (Math.round(b * 255)).toString(16).padStart(2, '0');
        }
        function lerp(a, b, t) { return a + t * (b - a); }
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        // Perlin noise
        const permutation = new Array(512);
        const p = new Array(256);
        for (let i = 0; i < 256; i++) { p[i] = Math.floor(Math.random() * 256); }
        for (let i = 0; i < 512; i++) { permutation[i] = p[i & 255]; }
        function grad(hash, x, y, z) {
            switch (hash & 0xF) {
                case 0x0: return x + y; case 0x1: return -x + y; case 0x2: return x - y;
                case 0x3: return -x - y; case 0x4: return x + z; case 0x5: return -x + z;
                case 0x6: return x - z; case 0x7: return -x - z; case 0x8: return y + z;
                case 0x9: return -y + z; case 0xA: return y - z; case 0xB: return -y - z;
                case 0xC: return y + x; case 0xD: return -y + z; case 0xE: return y - x;
                case 0xF: return -y - z; default: return 0;
            }
        }
        function perlinNoise(x, y, z) {
            let X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
            x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
            let u = fade(x), v = fade(y), w = fade(z);
            let A = permutation[X] + Y, AA = permutation[A] + Z, AB = permutation[A + 1] + Z;
            let B = permutation[X + 1] + Y, BA = permutation[B] + Z, BB = permutation[B + 1] + Z;
            return lerp(w, lerp(v, lerp(u, grad(permutation[AA], x, y, z), grad(permutation[BA], x - 1, y, z)),
                lerp(u, grad(permutation[AB], x, y - 1, z), grad(permutation[BB], x - 1, y - 1, z))),
                lerp(v, lerp(u, grad(permutation[AA + 1], x, y, z - 1), grad(permutation[BA + 1], x - 1, y, z - 1)),
                lerp(u, grad(permutation[AB + 1], x, y - 1, z - 1), grad(permutation[BB + 1], x - 1, y - 1, z - 1))));
        }

        // ---- 3D Point and Grid ----
        class Point3D {
            constructor(x, y, z) {
                this.x = x; this.y = y; this.z = z;
            }
        }
        function initGrid() {
            points = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                points.push([]);
                for (let j = 0; j < GRID_SIZE; j++) {
                    let x3D = (i - GRID_SIZE / 2) * CELL_SIZE;
                    let y3D = (j - GRID_SIZE / 2) * CELL_SIZE;
                    points[i].push(new Point3D(x3D, y3D, 0));
                }
            }
        }
        function project(p3d) {
            let tx = p3d.x - camera.x;
            let ty = p3d.y - camera.y;
            let tz = p3d.z - camera.z;
            let scale = camera.fov / (camera.fov + tz);
            let x2d = tx * scale + canvas.width / 2;
            let y2d = ty * scale + canvas.height / 2;
            return { x: x2d, y: y2d, scale: scale, depth: tz };
        }

        function drawGlitchyLine(p1, p2, scale, alpha = 1.0) {
            ctx.lineWidth = Math.max(0.25, 1 / (1 + p1.depth * 0.002));
            if (ctx.lineWidth < 0.2) return;

            let colorToUse = IS_RAINBOW_MODE ? hsvToRgb(globalTime * 0.0001 % 1, 1, 1) : BASE_LINE_COLOR;
            let opacity = Math.max(0.1, 1 - Math.abs(p1.depth) / 1500);
            ctx.strokeStyle = hexToRgbA(colorToUse, opacity * alpha);

            let startX = p1.x; let startY = p1.y; let endX = p2.x; let endY = p2.y;
            let numSegments = Math.max(2, Math.floor(Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2) / 20));
            numSegments = Math.min(numSegments, MAX_LINE_SEGMENTS);

            for (let i = 0; i < numSegments; i++) {
                let segStartX = lerp(startX, endX, i / numSegments);
                let segStartY = lerp(startY, endY, i / numSegments);
                let segEndX = lerp(startX, endX, (i + 1) / numSegments);
                let segEndY = lerp(startY, endY, (i + 1) / numSegments);

                let jitterFactor = GLITCH_INTENSITY + midHighEnergy / 10;
                let scaleFactor = 1 - scale;
                if (gridDetailReduced) jitterFactor *= 0.5;

                segStartX += (Math.random() - 0.5) * jitterFactor * scaleFactor;
                segStartY += (Math.random() - 0.5) * jitterFactor * scaleFactor;
                segEndX += (Math.random() - 0.5) * jitterFactor * scaleFactor;
                segEndY += (Math.random() - 0.5) * jitterFactor * scaleFactor;

                ctx.beginPath();
                ctx.moveTo(segStartX, segStartY);
                ctx.lineTo(segEndX, segEndY);
                ctx.stroke();
            }
        }

        // ---- Audio Analysis ----
        function analyzeAudio() {
            if (!analyser || audio.paused || audio.ended || !frequencyData) {
                bassEnergy = 0; midHighEnergy = 0; return;
            }
            analyser.getByteFrequencyData(frequencyData);

            let bassSum = 0, midHighSum = 0;
            const bassBins = Math.max(1, Math.floor(FFT_SIZE / 12));
            for (let i = 0; i < bassBins; i++) bassSum += frequencyData[i];
            const midHighStart = Math.floor(FFT_SIZE * 0.75);
            for (let i = midHighStart; i < FFT_SIZE / 2; i++) midHighSum += frequencyData[i];

            bassEnergy = bassBins > 0 ? (bassSum / bassBins / 255) * 0.85 : 0;
            midHighEnergy = ((FFT_SIZE / 2 - midHighStart) > 0)
                ? (midHighSum / (FFT_SIZE / 2 - midHighStart) / 255) * 0.85 : 0;

            // Guard against NaN
            if (isNaN(bassEnergy) || !isFinite(bassEnergy)) bassEnergy = 0;
            if (isNaN(midHighEnergy) || !isFinite(midHighEnergy)) midHighEnergy = 0;
        }

        // ---- Chill/Transition Drawing ----
        function drawChillParticles(alpha = 1.0) {
            ctx.save();
            ctx.globalAlpha = alpha;
            for (let i = 0; i < chillParticles.length; i++) {
                const p = chillParticles[i];
                p.pulse += p.pulseSpeed;
                let pulseR = p.baseR + Math.sin(p.pulse) * 3 + (Math.random() - 0.5) * 2;
                p.x += p.vx; p.y += p.vy;
                if (p.x > canvas.width) p.x = 0;
                if (p.x < 0) p.x = canvas.width;
                if (p.y > canvas.height) p.y = 0;
                if (p.y < 0) p.y = canvas.height;
                const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, pulseR);
                grad.addColorStop(0, `rgba(255,255,255,${p.opacity})`);
                grad.addColorStop(1, `rgba(255,255,255,0)`);
                ctx.beginPath();
                ctx.arc(p.x, p.y, pulseR, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
            }
            ctx.restore();
        }

        // ---- Main Draw ----
        function draw() {
            ctx.fillStyle = FOG_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let target = (visualizerActive && !(audio.paused || audio.currentTime === 0 || audio.ended)) ? 1 : 0;
            modeTransition += (target - modeTransition) * 0.09;
            modeTransition = Math.max(0, Math.min(1, modeTransition));
            if (isNaN(modeTransition) || !isFinite(modeTransition)) modeTransition = 0;

            if (modeTransition < 1) drawChillParticles(1 - modeTransition);

            if (modeTransition > 0.02) {
                analyzeAudio();
                const noiseZInput = globalTime * CURRENT_SPEED * 0.05 + bassEnergy * 5;
                for (let i = 0; i < points.length; i++) {
                    for (let j = 0; j < points[i].length; j++) {
                        let p = points[i][j];
                        const baseZ = perlinNoise(
                            (p.x + noiseOffset.x) * NOISE_SCALE,
                            (p.y + noiseOffset.y) * NOISE_SCALE,
                            noiseZInput
                        ) * MAX_Z_DEFORMATION;
                        const audioImpact = bassEnergy * MAX_Z_DEFORMATION * 2;
                        p.z = baseZ + audioImpact;
                    }
                }
                ctx.save();
                ctx.globalAlpha = modeTransition;
                for (let i = 0; i < points.length; i++) {
                    for (let j = 0; j < points[i].length; j++) {
                        let p1 = project(points[i][j]);
                        if (j < points[i].length - 1) {
                            let p2 = project(points[i][j + 1]);
                            drawGlitchyLine(p1, p2, p1.scale, 1.0);
                        }
                        if (i < points.length - 1 && points[i + 1]) {
                            let p2 = project(points[i + 1][j]);
                            drawGlitchyLine(p1, p2, p1.scale, 1.0);
                        }
                    }
                }
                ctx.restore();
            }
        }

        // ---- Animation Loop ----
        function animate() {
            try {
                globalTime++;
                // Camera movement
                if (!(audio.paused || audio.currentTime === 0 || audio.ended)) {
                    const forwardSpeed = 5 * CURRENT_SPEED;
                    camera.x += Math.sin(globalTime * 0.005) * 2 * CURRENT_SPEED;
                    camera.y = camera.targetY + Math.sin(globalTime * 0.003) * 50 * CURRENT_SPEED;
                    camera.z += forwardSpeed;
                    if (camera.z > 0) camera.z = -800;
                }
                // Defer grid resize (FPS adaptation) to start of frame
                if (pendingGridResize !== null) {
                    GRID_SIZE = pendingGridResize;
                    initGrid();
                    pendingGridResize = null;
                }
                draw();
                // FPS/performance
                frameCount++;
                let now = performance.now();
                if (now - fpsSampleStart > 700) {
                    fps = frameCount / ((now - fpsSampleStart) / 1000);
                    frameCount = 0;
                    fpsSampleStart = now;
                    // Schedule grid change for start of next frame, not mid-frame
                    if (fps < 28 && !gridDetailReduced) {
                        pendingGridResize = Math.max(18, Math.floor(GRID_SIZE * 0.68));
                        gridDetailReduced = true;
                    } else if (fps > 34 && gridDetailReduced) {
                        pendingGridResize = 32;
                        gridDetailReduced = false;
                    }
                }
                requestAnimationFrame(animate);
            } catch (err) {
                // Display error overlay for debugging
                ctx.save();
                ctx.fillStyle = "rgba(255,0,0,0.7)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#fff";
                ctx.font = "20px monospace";
                ctx.fillText("JS Error: " + err.message, 50, 80);
                ctx.restore();
                // Optionally, log to console as well
                console.error(err);
            }
        }

        // ---- Inputs ----
        speedSlider.addEventListener('input', (e) => {
            CURRENT_SPEED = e.target.value / 100;
        });
        colorPicker.addEventListener('input', (e) => {
            BASE_LINE_COLOR = e.target.value;
            IS_RAINBOW_MODE = false;
            rainbowButton.classList.remove('active');
        });
        rainbowButton.addEventListener('click', () => {
            IS_RAINBOW_MODE = !IS_RAINBOW_MODE;
            rainbowButton.classList.toggle('active', IS_RAINBOW_MODE);
        });
        canvas.addEventListener('click', () => {
            noiseOffset.x += (Math.random() * 1000 - 500) * (1 + bassEnergy * 2);
            noiseOffset.y += (Math.random() * 1000 - 500) * (1 + bassEnergy * 2);
            camera.targetY = (Math.random() - 0.5) * 300;
        });
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth * 0.95;
            canvas.height = window.innerHeight * 0.95;
            initGrid();
            spawnChillParticles();
        });

        // ---- Initial setup ----
        canvas.width = window.innerWidth * 0.95;
        canvas.height = window.innerHeight * 0.95;
        initGrid();
        spawnChillParticles();
        animate();
    </script>
</body>
</html>